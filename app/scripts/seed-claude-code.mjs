import { createClient } from '@supabase/supabase-js'
import { config } from 'dotenv'
import { resolve } from 'path'

config({ path: resolve(import.meta.dirname, '../.env.local') })

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
)

const items = [
  // ===================== FREE #1 =====================
  {
    slug: 'claude-code-bystryj-start',
    title: 'Claude Code: быстрый старт за 15 минут',
    description: 'Пошаговый гайд: установка, первый запуск, первая задача, ключевые команды. Всё, что нужно, чтобы начать работать с Claude Code прямо сейчас.',
    type: 'guide',
    tool: 'claude-code',
    is_premium: false,
    published: true,
    sort_order: 1,
    tags: ['claude code', 'быстрый старт', 'установка', 'терминал', 'гайд'],
    content_body: `<h2>Что такое Claude Code</h2>
<p>Claude Code. Это AI-агент от Anthropic, который работает прямо в твоём терминале. Он читает файлы проекта, пишет код, запускает команды, делает коммиты. Агент видит весь проект целиком и действует сам, а не просто генерирует куски кода для копипасты.</p>

<h2>Подготовка: Node.js</h2>
<p>Claude Code устанавливается через npm. Если Node.js уже стоит, пропусти этот шаг. Если нет:</p>
<pre><code>node -v</code></pre>
<p>Нет ответа или ошибка? Ставь Node.js с <strong>nodejs.org</strong>. Нужна версия 18 или выше. После установки перезапусти терминал и проверь снова.</p>

<h2>Установка Claude Code</h2>
<p>Одна команда:</p>
<pre><code>npm install -g @anthropic-ai/claude-code</code></pre>
<p>На macOS/Linux может понадобиться <code>sudo</code> перед командой. Установка занимает 20-30 секунд.</p>

<h2>Первый запуск</h2>
<p>Открой терминал, перейди в папку любого проекта и набери:</p>
<pre><code>claude</code></pre>
<p>При первом запуске Claude Code попросит авторизоваться. Откроется браузер, ты войдёшь в аккаунт Anthropic (или создашь новый). Понадобится платная подписка Claude Pro или API-ключ. После входа терминал покажет интерактивную строку ввода. Ты внутри.</p>

<h2>Первая задача</h2>
<p>Попробуй что-нибудь простое. Например:</p>
<pre><code>Создай файл hello.py с функцией, которая считает факториал числа. Добавь тесты.</code></pre>
<p>Claude Code сам создаст файл, напишет код, добавит тесты и предложит их запустить. Ты увидишь каждое действие в терминале и сможешь одобрить или отклонить. Ещё вариант: открой папку с существующим проектом и попроси <em>"объясни структуру этого проекта"</em>. Агент прочитает файлы и даст разбор.</p>

<h2>Ключевые команды</h2>
<p>Эти команды вводятся прямо в строке Claude Code:</p>
<ul>
<li><code>/init</code> создаёт файл CLAUDE.md с описанием проекта. Полезно запустить в начале работы с новым проектом.</li>
<li><code>/clear</code> очищает контекст разговора. Используй, когда переключаешься между задачами.</li>
<li><code>/compact</code> сжимает историю разговора, освобождает контекстное окно. Помогает при долгих сессиях.</li>
<li><code>/help</code> показывает все доступные команды.</li>
</ul>

<h2>Что такое CLAUDE.md</h2>
<p>Файл <code>CLAUDE.md</code> в корне проекта. Claude Code читает его при каждом запуске. Туда пишешь: какой стек используется, какие правила кодирования соблюдать, как запускать тесты. Считай, это инструкция для агента по твоему конкретному проекту. Чем точнее опишешь, тем лучше результат. Команда <code>/init</code> создаст заготовку автоматически.</p>

<h2>Практические советы</h2>
<ul>
<li>Будь конкретным в запросах. "Добавь валидацию email в форму регистрации" лучше, чем "улучши форму".</li>
<li>Claude Code видит весь проект. Не нужно копировать код в промпт, просто ссылайся на файлы.</li>
<li>Если агент идёт не туда, нажми <strong>Escape</strong> и переформулируй задачу.</li>
<li>Для рутинных задач (коммиты, рефакторинг, тесты) Claude Code экономит часы работы.</li>
</ul>

<h2>Что дальше</h2>
<p>Ты установил Claude Code и выполнил первую задачу. Следующий шаг: настрой <code>CLAUDE.md</code> для своего проекта и попробуй поработать с агентом на реальных задачах. В сообществе AI Pack есть продвинутые гайды по настройке, кастомным командам и интеграции с IDE.</p>`
  },

  // ===================== FREE #2 =====================
  {
    slug: 'claude-md-konstitutsiya-proekta',
    title: 'CLAUDE.md: как написать конституцию проекта',
    description: 'Что такое CLAUDE.md, как его структурировать, антипаттерны и готовый пример для реального проекта на Next.js + Supabase.',
    type: 'skill',
    tool: 'claude-code',
    is_premium: false,
    published: true,
    sort_order: 2,
    tags: ['CLAUDE.md', 'настройка', 'паттерн', 'конфигурация', 'контекст'],
    content_body: `<h2>Что такое CLAUDE.md</h2>

<p>CLAUDE.md. Это текстовый файл, который Claude Code читает <strong>перед каждым ответом</strong>. Всё, что вы туда запишете, становится постоянной инструкцией для агента. Промпт приходится повторять. Системное сообщение теряется через 10 минут. А CLAUDE.md остаётся. Постоянная память проекта.</p>

<p>По сути это конституция: набор правил, которые Claude обязан соблюдать при работе с вашим кодом. Один раз написали, дальше агент сам знает ваш стек, ваши команды, ваши запреты.</p>

<h2>Где лежит файл</h2>

<p>Три уровня, от общего к частному:</p>

<ul>
<li><strong>~/.claude/CLAUDE.md</strong> (глобальный). Действует во всех проектах. Сюда идут ваши личные предпочтения: язык общения, стиль ответов, общие запреты.</li>
<li><strong>CLAUDE.md в корне проекта</strong> (проектный). Действует для всех, кто работает с этим репозиторием. Коммитится в git. Сюда идёт стек, архитектура, код-стайл.</li>
<li><strong>.claude/CLAUDE.md</strong> (локальный проектный). Ваши личные настройки для конкретного проекта. Добавляется в .gitignore.</li>
</ul>

<p>Claude Code объединяет все три уровня. Проектный файл не перезаписывает глобальный, они работают вместе.</p>

<h2>Минимальный рабочий CLAUDE.md</h2>

<p>Не нужно писать роман. Вот файл, который уже приносит пользу:</p>

<pre><code># Проект: My App

## Стек
- Next.js 15 (App Router), TypeScript, Tailwind
- БД: Supabase (PostgreSQL)
- Деплой: Vercel

## Команды
- npm run dev # локальный сервер
- npm run build # проверка сборки
- npm run lint # линтер

## Правила кода
- Язык интерфейса: русский
- Компоненты: функциональные, без class components
- Импорты: абсолютные через @/</code></pre>

<p>15 строк. Claude теперь знает ваш стек и не предложит Express вместо Next.js или MySQL вместо Supabase.</p>

<h2>Структура хорошего файла</h2>

<p>Разбивайте на секции с понятными заголовками:</p>

<ul>
<li><strong>Стек и архитектура.</strong> Фреймворк, ORM, основные библиотеки. Структура папок, если нестандартная.</li>
<li><strong>Команды.</strong> Как запустить dev-сервер, тесты, линтер, сборку. Claude будет использовать именно их.</li>
<li><strong>Код-стайл.</strong> Именование файлов, структура компонентов, предпочтения по импортам.</li>
<li><strong>Запреты.</strong> Чего Claude не должен делать. "Не используй any в TypeScript". "Не создавай файлы в корне". "Не коммить .env".</li>
<li><strong>Контекст проекта.</strong> Роли пользователей, ключевые сущности, бизнес-логика, которую агент должен учитывать.</li>
</ul>

<h2>Антипаттерны</h2>

<h3>Файл на 200+ строк</h3>
<p>Чем длиннее CLAUDE.md, тем больше контекстного окна он съедает. Каждая строка отнимает место у вашего реального диалога. Будьте безжалостны к объёму.</p>

<h3>Копирование чужого файла целиком</h3>
<p>Чужой CLAUDE.md написан под чужой проект, чужой стек и чужие привычки. Скопировать и вставить = загрузить агента нерелевантными правилами. Берите идеи, но пишите под себя.</p>

<h3>Противоречащие правила</h3>
<p>"Пиши короткие функции" + "Не разбивай логику на мелкие функции". Claude не скажет вам об этом, просто будет хаотично выбирать одно из двух.</p>

<h2>Главное правило</h2>

<p><strong>Если убрать строку из CLAUDE.md и Claude всё равно не ошибётся, эта строка не нужна.</strong></p>

<p>Не пишите очевидное. "Используй TypeScript" в TypeScript-проекте. "Пиши чистый код". "Следуй best practices". Это мусор, который размывает действительно важные инструкции.</p>

<h2>Пример для реального проекта</h2>

<pre><code># Проект: AI Community Platform

## Стек
- Next.js 15 App Router, TypeScript strict, Tailwind + shadcn/ui
- Supabase: PostgreSQL, Auth через кастомные сессии
- Деплой: Vercel с ветки master

## Архитектура
- Route groups: (public) для открытых страниц, (members) для закрытых
- Сессии: кастомные JWT cookies через lib/session.ts
- Роли: free, member, admin
- Серверные компоненты по умолчанию, "use client" только при необходимости

## Команды
- npm run dev # локальная разработка
- npm run build # проверка перед деплоем
- npx supabase db push # применить миграции

## Запреты
- Не использовать any, только явные типы
- Не коммитить .env и ключи
- Не менять схему БД вручную, только через миграции в supabase/migrations/
- Не создавать API routes там, где достаточно Server Action

## Стиль
- Язык интерфейса: русский
- Компоненты: один файл = один компонент
- Именование файлов: kebab-case</code></pre>

<p>Этого достаточно, чтобы Claude Code работал с проектом так, будто он читал всю документацию. Начните с минимума, добавляйте правила только когда агент реально ошибается без них.</p>`
  },

  // ===================== FREE #3 =====================
  {
    slug: 'claude-code-lending-golosom',
    title: 'Claude Code для не-программистов: делаем лендинг голосом',
    description: 'Как создать рабочий лендинг за 15 минут без единой строки кода. Vibe coding: описываешь словами, получаешь сайт.',
    type: 'guide',
    tool: 'claude-code',
    is_premium: false,
    published: true,
    sort_order: 3,
    tags: ['vibe coding', 'лендинг', 'без кода', 'не-программист', 'быстрый результат'],
    content_body: `<h2>Что такое "vibe coding" и как это работает</h2>

<p>Вы описываете словами, что хотите видеть на сайте. Claude Code пишет весь код за вас. Ни одной строки вручную. Просто говорите: "Хочу красивый лендинг для цветочной мастерской". И получаете рабочий сайт.</p>

<p>Это называют <strong>vibe coding</strong>. Вы задаёте настроение, направление, смысл. AI превращает это в работающий код.</p>

<h2>Подготовка: 2 минуты</h2>

<p>Вам понадобится установленный Claude Code. Если ещё не установили, посмотрите наш гайд по установке.</p>

<p>Создайте пустую папку для проекта. Например, <strong>my-landing</strong>. Откройте терминал в этой папке и запустите:</p>

<pre><code>claude</code></pre>

<p>Появится интерфейс Claude Code. Всё, вы готовы.</p>

<h2>Первый промпт: описываем лендинг</h2>

<p>Просто напишите, что вам нужно. Чем конкретнее, тем лучше. Вот пример:</p>

<pre><code>Создай одностраничный лендинг для цветочной мастерской "Полевые".
Блоки: шапка с названием и слоганом "Букеты с характером",
каталог из 3 карточек с букетами (придумай названия и цены),
блок "О нас" с коротким текстом,
форма заказа с полями имя и телефон,
подвал с адресом и телефоном.
Стиль: мягкие пастельные тона, современный шрифт,
адаптивная вёрстка для мобильных.
Всё в одном HTML-файле.</code></pre>

<p>Нажмите Enter и наблюдайте. Claude Code сам создаст файл <strong>index.html</strong> со всем кодом внутри.</p>

<h2>Что произойдёт дальше</h2>

<p>Claude Code начнёт писать код прямо при вас. Вы увидите, как создаётся файл, как добавляются стили и структура страницы. Через пару минут всё будет готово.</p>

<p>Откройте файл <strong>index.html</strong> в браузере. Просто дважды кликните по нему. Перед вами готовый лендинг с дизайном, текстами и формой.</p>

<h2>Итерации: улучшаем голосом</h2>

<p>Лендинг готов, но хочется поправить детали. Просто пишите в том же чате:</p>

<ul>
<li><code>Сделай кнопку заказа крупнее и ярче</code></li>
<li><code>Поменяй цветовую палитру на сине-белую</code></li>
<li><code>Добавь блок с отзывами клиентов, придумай 3 отзыва</code></li>
<li><code>Сделай так, чтобы шапка была фиксированной при прокрутке</code></li>
<li><code>Добавь анимацию появления карточек при скролле</code></li>
</ul>

<p>Каждый раз Claude Code внесёт изменения в файл. Обновите страницу в браузере и увидите результат. Весь цикл правки занимает <strong>30 секунд</strong>.</p>

<h2>Результат</h2>

<p>За <strong>10-15 минут</strong> у вас есть рабочий лендинг. С дизайном, адаптивной вёрсткой, формой обратной связи. Без единой написанной вами строки кода. Файл можно залить на любой хостинг.</p>

<h2>Что Claude Code может и чего не может</h2>

<p><strong>Может:</strong></p>
<ul>
<li>Создавать HTML-страницы любой сложности</li>
<li>Делать адаптивный дизайн для мобильных</li>
<li>Добавлять анимации, формы, галереи</li>
<li>Переделывать и дорабатывать по вашим просьбам</li>
</ul>

<p><strong>Ограничения:</strong></p>
<ul>
<li>Форма на лендинге не будет отправлять данные без серверной части. Для простого сбора заявок можно попросить Claude Code подключить сторонний сервис</li>
<li>Для публикации сайта в интернете нужен хостинг. Claude Code создаёт файлы, но не размещает их онлайн</li>
<li>Сложные интернет-магазины с оплатой и базой данных потребуют больше шагов и технического понимания</li>
</ul>

<p><em>Начните с простого лендинга. Убедитесь, что это работает. Потом усложняйте.</em></p>`
  },

  // ===================== PREMIUM #4 =====================
  {
    slug: 'polnaya-nastrojka-hooks-skills-mcp',
    title: 'Полная настройка Claude Code: hooks, skills, MCP',
    description: 'Три продвинутые фичи, которые превращают Claude Code в систему разработки: автоматизация через hooks, экспертиза через skills, интеграции через MCP.',
    type: 'guide',
    tool: 'claude-code',
    is_premium: true,
    published: true,
    sort_order: 10,
    tags: ['hooks', 'skills', 'MCP', 'система', 'продвинутая настройка'],
    content_body: `<h2>Hooks: автоматизация lifecycle Claude Code</h2>

<p>Hooks позволяют выполнять shell-команды на определённых этапах работы Claude Code. Вы описываете правила один раз: какой линтер запускать, когда прогонять тесты, как форматировать код. Дальше система выполняет это автоматически при каждом изменении.</p>

<h3>Типы hooks</h3>
<ul>
<li><strong>PreToolUse</strong>: срабатывает перед вызовом инструмента (например, перед записью файла)</li>
<li><strong>PostToolUse</strong>: срабатывает после вызова инструмента (после записи файла, после выполнения команды)</li>
<li><strong>Notification</strong>: срабатывает когда Claude Code отправляет уведомление</li>
<li><strong>Stop</strong>: срабатывает когда агент завершает работу над задачей</li>
</ul>

<h3>Пример 1: автоформатирование через Prettier</h3>
<p>После каждого изменения файла Claude Code автоматически прогоняет Prettier. Форматирование происходит само, без дополнительных команд.</p>

<pre><code>{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hook": "npx prettier --write $CLAUDE_FILE_PATH"
      }
    ]
  }
}</code></pre>

<p><strong>matcher</strong> фильтрует, на какие инструменты реагировать. <code>Write|Edit</code> означает: только после записи или редактирования файла. Переменная <code>$CLAUDE_FILE_PATH</code> содержит путь к изменённому файлу.</p>

<h3>Пример 2: автоматический запуск тестов</h3>
<p>Каждый раз, когда Claude Code редактирует файл в папке <code>src/</code>, запускаются связанные тесты. Если тесты падают, агент сразу видит ошибку и исправляет код.</p>

<pre><code>{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hook": "if echo $CLAUDE_FILE_PATH | grep -q 'src/'; then npm test -- --findRelatedTests $CLAUDE_FILE_PATH 2>&1 | tail -20; fi"
      }
    ]
  }
}</code></pre>

<h3>Где настраивать</h3>
<p>Hooks добавляются в файл <code>.claude/settings.json</code> в корне проекта. Этот файл коммитится в репозиторий, поэтому настройки работают у всей команды.</p>

<h2>Skills: инструкции, которые подгружаются по контексту</h2>

<p>CLAUDE.md загружается всегда и целиком. Это удобно для базовых правил, но быстро раздувается. Skills решают эту проблему: каждый скилл хранится в отдельном файле и подгружается только когда Claude Code определяет его релевантность текущей задаче.</p>

<h3>Где хранить</h3>
<ul>
<li><code>.claude/skills/</code> в проекте: скиллы, специфичные для этого проекта</li>
<li><code>~/.claude/skills/</code> глобально: скиллы, которые работают во всех проектах</li>
</ul>

<h3>Пример: скилл для код-ревью</h3>
<p>Файл <code>.claude/skills/code-review.md</code>:</p>

<pre><code># Скилл: Code Review

## Когда применять
При запросах на ревью кода, проверку PR, анализ изменений.

## Чеклист проверки
1. Типизация: нет ли any, корректны ли generic-типы
2. Обработка ошибок: все async/await обёрнуты в try-catch
3. Производительность: нет ли лишних ре-рендеров, мемоизация где нужно
4. Безопасность: нет ли SQL-инъекций, XSS, утечек секретов
5. Тесты: покрыты ли edge cases

## Формат ответа
Для каждого замечания указывай:
- Файл и строку
- Severity: critical / warning / suggestion
- Конкретное исправление, не общие слова</code></pre>

<h3>Пример: скилл для написания тестов</h3>
<p>Файл <code>.claude/skills/testing.md</code>:</p>

<pre><code># Скилл: Написание тестов

## Когда применять
При создании или обновлении тестов, при запросах "напиши тесты", "покрой тестами".

## Правила
- Использовать describe/it, не test()
- Каждый тест проверяет одно поведение
- Название теста описывает ожидание: "should return 404 when user not found"
- Обязательно тестировать: happy path, edge cases, error handling
- Моки только для внешних зависимостей, не для внутренней логики

## Структура файла
1. Импорты
2. Моки и фикстуры
3. describe-блок с названием модуля
4. beforeEach для общего setup
5. Тесты от простого к сложному</code></pre>

<p>В отличие от CLAUDE.md, эти инструкции не тратят контекстное окно, пока не понадобятся. В проекте с 10-15 скиллами экономия заметная.</p>

<h2>MCP-серверы: подключение внешних сервисов</h2>

<p>Model Context Protocol (MCP) позволяет Claude Code взаимодействовать с внешними системами: GitHub, базами данных, Slack, файловыми хранилищами. Агент получает доступ к реальным данным и может выполнять действия в этих системах.</p>

<h3>Как подключить</h3>
<p>MCP-серверы настраиваются в том же <code>.claude/settings.json</code>:</p>

<pre><code>{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "ghp_your_token_here"
      }
    }
  }
}</code></pre>

<p><strong>Важно:</strong> токены лучше хранить не в <code>.claude/settings.json</code> (он в репозитории), а в <code>.claude/settings.local.json</code>, который добавлен в <code>.gitignore</code>.</p>

<h3>Что даёт GitHub MCP</h3>
<ul>
<li>Claude Code видит ваши issues, может читать описания и комментарии</li>
<li>Создаёт pull requests с описанием и привязкой к issue</li>
<li>Читает код-ревью и отвечает на замечания</li>
<li>Ищет по репозиторию через GitHub API</li>
</ul>

<h3>Популярные MCP-серверы</h3>
<ul>
<li><strong>@modelcontextprotocol/server-github</strong>: работа с GitHub</li>
<li><strong>@modelcontextprotocol/server-filesystem</strong>: расширенный доступ к файловой системе</li>
<li><strong>@modelcontextprotocol/server-postgres</strong>: прямые запросы к PostgreSQL</li>
<li><strong>@modelcontextprotocol/server-slack</strong>: чтение и отправка сообщений в Slack</li>
</ul>

<h3>Пример: добавление нескольких серверов</h3>

<pre><code>{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "\${GITHUB_TOKEN}"
      }
    },
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "DATABASE_URL": "\${DATABASE_URL}"
      }
    }
  }
}</code></pre>

<h2>Как всё работает вместе</h2>

<p>Каждая фича закрывает свой слой автоматизации:</p>
<ul>
<li><strong>Hooks</strong> автоматизируют рутинные операции: форматирование, линтинг, тесты. Больше никаких "ещё отформатируй" или "запусти тесты".</li>
<li><strong>Skills</strong> дают Claude Code экспертизу вашей команды: стандарты кода, паттерны, процессы. Агент работает по вашим правилам.</li>
<li><strong>MCP</strong> подключает внешний мир: тикеты, PR, базы данных, мессенджеры. Claude Code встраивается в рабочий процесс целиком.</li>
</ul>

<h3>Минимальная боевая конфигурация</h3>
<p>Файл <code>.claude/settings.json</code> для старта:</p>

<pre><code>{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hook": "npx prettier --write $CLAUDE_FILE_PATH"
      }
    ],
    "Stop": [
      {
        "hook": "npm test 2>&1 | tail -30"
      }
    ]
  },
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "\${GITHUB_TOKEN}"
      }
    }
  }
}</code></pre>

<p>Плюс 2-3 скилла в <code>.claude/skills/</code> под специфику проекта. Такая конфигурация закрывает большинство потребностей типичного проекта. Настройка занимает минут 15.</p>`
  },

  // ===================== PREMIUM #5 =====================
  {
    slug: '5-gotovyh-claude-md-shablonov',
    title: '5 готовых CLAUDE.md для бизнес-задач',
    description: '5 шаблонов CLAUDE.md для разных типов проектов: SaaS, лендинг, API, блог, Python-аналитика. Скопируй, подставь свои данные, работай.',
    type: 'template',
    tool: 'claude-code',
    is_premium: true,
    published: true,
    sort_order: 11,
    tags: ['шаблон', 'CLAUDE.md', 'бизнес', 'копировать', 'конфигурация'],
    content_body: `<h2>Как использовать</h2>
<p>Выберите шаблон под свой тип проекта. Скопируйте содержимое в файл <code>CLAUDE.md</code> в корне репозитория. Замените все значения в квадратных скобках <code>[ЗАМЕНИ_НА_СВОЕ]</code> на свои данные.</p>

<h2>1. SaaS-проект (Next.js + Supabase)</h2>
<p>Для fullstack-приложений на Next.js с Supabase в качестве бэкенда. Подходит для SaaS, дашбордов, личных кабинетов.</p>
<pre><code># Проект: [ЗАМЕНИ_НА_СВОЕ: название проекта]

## Стек
- Next.js 15 (App Router), TypeScript strict, Tailwind CSS
- Supabase (PostgreSQL, Auth, Storage)
- Деплой: Vercel

## Структура
- app/src/app/ — роуты (App Router)
- app/src/components/ — React-компоненты
- app/src/lib/ — утилиты, клиенты Supabase
- supabase/migrations/ — SQL-миграции

## Команды
- npm run dev — локальный сервер
- npm run build — сборка
- npm run lint — проверка кода
- npx supabase db push — применить миграции

## Правила кодирования
- TypeScript strict mode. Никаких any.
- Серверные компоненты по умолчанию. 'use client' только при необходимости.
- Импорты: @/ для абсолютных путей от src/.
- Стили: только Tailwind-классы. Никаких inline-стилей и CSS-файлов.
- Компоненты UI: использовать shadcn/ui из @/components/ui/.

## Supabase
- Все изменения схемы БД через миграции в supabase/migrations/.
- Использовать RLS. Service role key только на серверной стороне.
- Не менять схему вручную через Dashboard.

## Запреты
- НЕ коммитить .env, ключи, секреты.
- НЕ менять миграции, которые уже применены.
- НЕ использовать Pages Router, только App Router.
- НЕ создавать файлы без необходимости. Предпочитать редактирование существующих.</code></pre>
<p><strong>Совет:</strong> добавьте секцию с описанием ролей пользователей и правил авторизации, если в проекте есть разграничение доступа.</p>

<h2>2. Лендинг / маркетинговый сайт</h2>
<p>Для одностраничников, промо-сайтов и маркетинговых лендингов. Фокус на скорость, SEO и конверсию.</p>
<pre><code># Проект: [ЗАМЕНИ_НА_СВОЕ: название лендинга]

## Стек
- [ЗАМЕНИ_НА_СВОЕ: HTML/CSS/JS или Astro или Next.js static]
- Деплой: [ЗАМЕНИ_НА_СВОЕ: Vercel / Netlify / Cloudflare Pages]

## Структура
- src/pages/ — страницы
- src/components/ — переиспользуемые блоки
- src/assets/ — изображения, шрифты
- public/ — статичные файлы

## Правила
- Mobile-first. Все стили начинаются с мобильной версии.
- Семантический HTML: header, main, section, article, footer.
- Все изображения: WebP формат, атрибуты width/height, lazy loading.
- Шрифты: preload, display=swap. Максимум 2 шрифта.
- Никаких внешних JS-библиотек без явной необходимости.

## SEO-требования
- Каждая страница: уникальный title (до 60 символов) и meta description (до 155 символов).
- Один h1 на страницу. Иерархия заголовков: h1 > h2 > h3.
- Alt-текст для всех изображений.
- Canonical URL на каждой странице.
- Open Graph и Twitter Card мета-теги.

## Производительность
- Целевые показатели: LCP &lt; 2.5s, CLS &lt; 0.1, FID &lt; 100ms.
- CSS: критические стили inline, остальное асинхронно.
- Минимизировать DOM-глубину (не более 5 уровней вложенности).

## Запреты
- НЕ использовать jQuery или тяжёлые фреймворки.
- НЕ загружать изображения без оптимизации.
- НЕ добавлять анимации, блокирующие рендеринг.</code></pre>
<p><strong>Совет:</strong> если лендинг на Astro, добавьте правила по островкам (islands) и укажите, какие компоненты требуют client:load.</p>

<h2>3. API-сервис (Express / Fastify)</h2>
<p>Для бэкенд-сервисов с REST API. Подходит для микросервисов, интеграций, вебхуков.</p>
<pre><code># Проект: [ЗАМЕНИ_НА_СВОЕ: название API-сервиса]

## Стек
- Node.js, [ЗАМЕНИ_НА_СВОЕ: Express / Fastify], TypeScript
- БД: [ЗАМЕНИ_НА_СВОЕ: PostgreSQL / MongoDB / SQLite]
- ORM: [ЗАМЕНИ_НА_СВОЕ: Prisma / Drizzle / TypeORM]

## Структура
- src/routes/ — маршруты API
- src/controllers/ — логика обработки запросов
- src/services/ — бизнес-логика
- src/middleware/ — middleware (auth, validation, error handling)
- src/models/ — модели данных
- src/utils/ — утилиты
- tests/ — тесты

## Команды
- npm run dev — сервер с hot reload
- npm run build — сборка TypeScript
- npm test — запуск тестов
- npm run lint — проверка кода

## REST API конвенции
- Именование: /api/v1/[ресурс] (множественное число, kebab-case).
- Методы: GET (чтение), POST (создание), PUT (замена), PATCH (частичное обновление), DELETE (удаление).
- Коды ответов: 200 (ОК), 201 (создано), 400 (ошибка валидации), 401 (не авторизован), 403 (нет доступа), 404 (не найдено), 500 (серверная ошибка).
- Формат ошибок: { "error": "описание", "code": "ERROR_CODE" }.

## Валидация и безопасность
- Все входные данные валидировать через [ЗАМЕНИ_НА_СВОЕ: Zod / Joi / Ajv].
- Rate limiting на все публичные эндпоинты.
- Helmet для заголовков безопасности.
- CORS: разрешать только [ЗАМЕНИ_НА_СВОЕ: список доменов].
- SQL-инъекции: использовать параметризованные запросы, никогда не конкатенировать строки.
- Не логировать тела запросов с паролями и токенами.

## Запреты
- НЕ хранить секреты в коде. Только через env-переменные.
- НЕ возвращать stack trace в production.
- НЕ использовать sync-операции (fs.readFileSync и подобные).
- НЕ игнорировать ошибки: каждый catch должен логировать или пробрасывать.</code></pre>
<p><strong>Совет:</strong> добавьте секцию с форматом логирования и описание health-check эндпоинта, если сервис работает в Docker/Kubernetes.</p>

<h2>4. Контент-проект (блог, документация)</h2>
<p>Для блогов, баз знаний и документации. Контент в Markdown-файлах с frontmatter-метаданными.</p>
<pre><code># Проект: [ЗАМЕНИ_НА_СВОЕ: название блога/документации]

## Стек
- [ЗАМЕНИ_НА_СВОЕ: Astro / Next.js / Hugo / Docusaurus]
- Контент: Markdown (.md / .mdx)
- Деплой: [ЗАМЕНИ_НА_СВОЕ: Vercel / Netlify / GitHub Pages]

## Структура
- content/posts/ — статьи блога
- content/docs/ — документация
- src/layouts/ — шаблоны страниц
- public/images/ — изображения для статей

## Формат frontmatter
---
title: "Заголовок статьи"
description: "Описание для SEO (до 155 символов)"
date: YYYY-MM-DD
author: "[ЗАМЕНИ_НА_СВОЕ]"
tags: ["тег1", "тег2"]
published: true
---

## Правила контента
- Один h1 на страницу (берётся из frontmatter title).
- В тексте использовать h2 и h3. Не пропускать уровни.
- Абзацы: 2-4 предложения. Стена текста недопустима.
- Списки: для перечислений от 3 пунктов.
- Код: всегда с указанием языка.
- Изображения: alt-текст обязателен, формат WebP, ширина до 1200px.

## Тон и стиль
- [ЗАМЕНИ_НА_СВОЕ: формальный / неформальный / технический].
- Обращение к читателю: [ЗАМЕНИ_НА_СВОЕ: "вы" / "ты"].
- Без воды: каждое предложение несёт смысл.
- Термины при первом упоминании объяснять или давать ссылку.

## SEO-чеклист для каждой статьи
- [ ] Title до 60 символов с ключевым словом.
- [ ] Description до 155 символов.
- [ ] URL: короткий, kebab-case, без дат.
- [ ] Внутренние ссылки: минимум 2 на релевантные страницы.
- [ ] Изображения с alt-текстом.

## Запреты
- НЕ публиковать без заполненного frontmatter.
- НЕ использовать HTML внутри Markdown без крайней необходимости.
- НЕ дублировать контент между страницами.</code></pre>
<p><strong>Совет:</strong> если проект на MDX, добавьте список доступных кастомных компонентов (Callout, CodeBlock, Tabs) и примеры их использования.</p>

<h2>5. Аналитика и скрипты (Python)</h2>
<p>Для data-пайплайнов, аналитических скриптов и Jupyter-ноутбуков. Pandas, NumPy, matplotlib.</p>
<pre><code># Проект: [ЗАМЕНИ_НА_СВОЕ: название проекта]

## Стек
- Python 3.11+
- Зависимости: pandas, numpy, matplotlib, [ЗАМЕНИ_НА_СВОЕ: дополнительные библиотеки]
- Virtual env: venv или poetry

## Структура
- src/ — основной код
- src/data/ — загрузка и обработка данных
- src/analysis/ — аналитические скрипты
- src/visualization/ — графики и отчёты
- notebooks/ — Jupyter-ноутбуки
- data/raw/ — исходные данные (не коммитить)
- data/processed/ — обработанные данные
- output/ — результаты: CSV, графики, отчёты
- tests/ — тесты

## Команды
- python -m venv venv — создать виртуальное окружение
- pip install -r requirements.txt — установить зависимости
- python src/main.py — запуск основного скрипта
- pytest tests/ — запуск тестов

## Правила кодирования
- Type hints для всех функций и параметров.
- Docstrings (Google-стиль) для каждой публичной функции.
- Именование: snake_case для функций и переменных, PascalCase для классов.
- Максимальная длина строки: 100 символов.
- Импорты: стандартная библиотека, сторонние пакеты, локальные модули (разделять пустой строкой).

## Работа с данными
- Входные данные читать из data/raw/.
- Результаты сохранять в output/.
- CSV: разделитель запятая, кодировка UTF-8, заголовки в первой строке.
- Графики matplotlib: figsize=(10, 6), dpi=150, формат PNG.
- Большие файлы (более 50 МБ): не коммитить, добавить в .gitignore.

## Формат вывода
- Таблицы: CSV с заголовками.
- Графики: PNG, подписи осей на [ЗАМЕНИ_НА_СВОЕ: русском / английском].
- Логи: print() с временной меткой для длительных операций.

## Запреты
- НЕ коммитить data/raw/ и виртуальное окружение.
- НЕ хардкодить пути. Использовать pathlib.Path и относительные пути.
- НЕ подавлять предупреждения (warnings.filterwarnings('ignore')) без причины.
- НЕ оставлять закомментированный код. Удалять или оформлять в функцию.</code></pre>
<p><strong>Совет:</strong> для проектов с ML-моделями добавьте секцию с правилами версионирования моделей и формата логирования экспериментов (MLflow, W&amp;B).</p>`
  },

  // ===================== PREMIUM #6 =====================
  {
    slug: 'sub-agents-delegirovanie-zadach',
    title: 'Sub-agents: делегируй задачи внутри Claude Code',
    description: 'Подагенты в Claude Code: как разгрузить контекст, ускорить работу и экономить токены через делегирование задач отдельным агентам.',
    type: 'skill',
    tool: 'claude-code',
    is_premium: true,
    published: true,
    sort_order: 12,
    tags: ['sub-agents', 'делегирование', 'оптимизация', 'токены', 'параллельность'],
    content_body: `<h2>Проблема длинных сессий</h2>

<p>У Claude Code есть контекстное окно. Это объём информации, который модель удерживает "в голове" одновременно. Представь рабочий стол: чем больше на нём бумаг, тем сложнее найти нужную.</p>

<p>После 50-100 обменов в одной сессии качество ответов падает. Claude Code начинает "забывать" инструкции из начала разговора, путает имена файлов, повторяет уже сделанное. Расход токенов при этом растёт резко: каждое новое сообщение включает всю предыдущую историю.</p>

<p><strong>Типичная ошибка:</strong> одна сессия на весь день работы. К вечеру модель работает хуже, чем утром, и стоит в разы дороже.</p>

<h2>Что такое sub-agents</h2>

<p>Sub-agent (подагент). Это отдельная мини-сессия, которую Claude Code запускает внутри основной. У подагента свой контекст, свой системный промпт, свои инструменты. Он выполняет задачу и возвращает только результат. Промежуточные шаги не попадают в основную сессию.</p>

<p>Аналогия: ты руководитель. Вместо того чтобы самому искать информацию, ты отправляешь помощника. Он возвращается с ответом. Твой рабочий стол остаётся чистым.</p>

<p>Claude Code использует подагентов через <strong>Task tool</strong>. Типы задач, которые он делегирует:</p>
<ul>
<li><strong>Поиск по кодовой базе</strong> (Explore agent). Сканирует файлы, не раздувая основной контекст</li>
<li><strong>Параллельные операции.</strong> Несколько файлов редактируются одновременно через разных агентов</li>
<li><strong>Планирование.</strong> Отдельный агент анализирует задачу и предлагает план</li>
<li><strong>Исследование.</strong> Агент читает документацию, код, зависимости и возвращает сводку</li>
</ul>

<h2>Как заставить Claude Code делегировать</h2>

<p>Claude Code сам решает, когда запускать подагента. Но ты можешь повлиять на это через <strong>CLAUDE.md</strong>. Добавь правила делегирования:</p>

<pre><code># Правила делегирования

## Поиск и исследование
- Для поиска по кодовой базе используй Task agent. Не ищи напрямую в основной сессии, если нужно проверить больше 5 файлов.
- Для исследования архитектуры или зависимостей используй отдельного агента и верни сводку.

## Параллельные задачи
- Если задача включает изменения в 3+ независимых файлах, запускай агентов параллельно.

## Защита контекста
- Тяжёлый анализ (чтение больших файлов, сравнение реализаций) делегируй подагенту.
- В основной сессии работай только с результатами, не с сырыми данными.</code></pre>

<h2>Практические паттерны</h2>

<h3>Паттерн "Исследователь"</h3>
<p>Отдельный агент получает задачу: изучить часть кодовой базы и вернуть структурированный отчёт. Основная сессия получает только итог.</p>
<p><strong>Что написать Claude Code:</strong></p>
<pre><code>Исследуй, как реализована аутентификация в проекте.
Найди все файлы, связанные с auth, определи flow
(регистрация, логин, сессии), верни краткую сводку
с путями к ключевым файлам.</code></pre>
<p>Claude Code запустит Task agent, который прочитает десятки файлов. В основную сессию вернётся только сводка на 10-15 строк.</p>

<h3>Паттерн "Параллельные задачи"</h3>
<p>Несколько независимых изменений выполняются одновременно. Каждый агент работает со своим файлом.</p>
<p><strong>Что написать Claude Code:</strong></p>
<pre><code>Обнови все три компонента одновременно:
1. Header.tsx: добавь мобильное меню
2. Footer.tsx: добавь ссылки на соцсети
3. Sidebar.tsx: добавь состояние collapsed
Каждый компонент меняй независимо.</code></pre>

<h3>Паттерн "Защита контекста"</h3>
<p>Самый полезный паттерн. Основная сессия остаётся лёгкой, потому что вся "грязная работа" уходит подагентам.</p>
<p><strong>Что написать Claude Code:</strong></p>
<pre><code>Перед тем как рефакторить модуль оплаты,
запусти отдельного агента для анализа текущей реализации.
Пусть он найдёт все зависимости, проверит тесты,
определит API-контракты. Верни мне только список
того, что нужно изменить, и порядок действий.</code></pre>

<h2>Экономия токенов</h2>

<p>Каждый подагент работает в изолированном контексте. Он не тащит за собой всю историю основной сессии. Основная сессия не раздувается от промежуточных результатов поиска, чтения файлов, проб и ошибок.</p>

<p><strong>Когда делегировать:</strong></p>
<ul>
<li>Нужно прочитать больше 3-5 файлов для ответа на вопрос</li>
<li>Задача не зависит от предыдущего контекста сессии</li>
<li>Можно выполнить несколько задач параллельно</li>
<li>Результат нужен в сжатом виде, а не в сыром</li>
</ul>

<p><strong>Когда делать в основной сессии:</strong></p>
<ul>
<li>Правка одного файла, где важен контекст обсуждения</li>
<li>Итеративная работа: написал, проверил, поправил</li>
<li>Задача требует знания всего предыдущего разговора</li>
</ul>

<p>Sub-agents есть только в Claude Code. В Cursor и Copilot такого механизма нет. Используй делегирование осознанно, и контекстное окно не будет забиваться мусором.</p>`
  },

  // ===================== PREMIUM #7 =====================
  {
    slug: 'mvp-za-odin-den',
    title: 'От идеи до деплоя: строим MVP за один день',
    description: 'Полный пошаговый воркфлоу: от идеи до работающего продукта в интернете за один день. Claude Code как персональный разработчик, Supabase для базы, Vercel для деплоя.',
    type: 'workflow',
    tool: 'claude-code',
    is_premium: true,
    published: true,
    sort_order: 13,
    tags: ['MVP', 'деплой', 'воркфлоу', 'продукт', 'стартап', 'Vercel'],
    content_body: `<h2>Зачем этот воркфлоу</h2>

<p>Раньше путь от идеи до работающего продукта занимал недели. Код, деплой, база данных, авторизация. Каждый этап требовал отдельных навыков и времени. С Claude Code этот путь сжимается до одного дня. Результат: работающее веб-приложение с базой данных, авторизацией и логикой, которую можно показать пользователям.</p>

<p>Этот воркфлоу проведёт вас через весь процесс. Утром формулируете идею, вечером открываете рабочий продукт. В качестве примера мы соберём SaaS-инструмент для генерации контент-планов: пользователь вводит нишу, получает план на месяц.</p>

<p>Что понадобится: Claude Code (подписка Max или API), аккаунт на Vercel (бесплатный), аккаунт на Supabase (бесплатный), базовое понимание, что такое веб-приложение. Писать код самостоятельно не нужно.</p>

<h2>Этап 1: Утро. Планирование (08:00 - 08:30)</h2>

<h3>Формулировка идеи</h3>

<p>Запишите идею в одном предложении. Не абзац, не страница. Одно предложение, которое отвечает на вопрос: "Что пользователь делает и что получает?"</p>

<p>Наш пример: <strong>"Пользователь вводит свою нишу и целевую аудиторию, а система генерирует контент-план на 30 дней с темами, форматами и хуками для каждого поста."</strong></p>

<h3>Техническое задание через Claude Code</h3>

<p>Откройте терминал, создайте папку проекта и запустите Claude Code. Первый промпт задаёт направление всей работы.</p>

<pre><code>Составь техническое задание для веб-приложения:

Продукт: SaaS-генератор контент-планов.
Пользователь вводит нишу и описание целевой аудитории.
Система генерирует контент-план на 30 дней: тема, формат поста,
крючок (первое предложение), этап воронки (ToFu/MoFu/BoFu).

Стек: Next.js 15 App Router, TypeScript, Tailwind CSS, shadcn/ui,
Supabase (БД + авторизация), OpenAI API для генерации.

Страницы: лендинг, авторизация, дашборд с историей планов,
страница генерации, страница просмотра плана.

Опиши: структуру папок, модели данных, API-роуты, основные компоненты.
Формат: markdown-документ, готовый стать основой CLAUDE.md.</code></pre>

<p>Claude Code выдаст структурированное ТЗ. Проверьте его, скорректируйте, если нужно, и сохраните как основу.</p>

<h3>Создание CLAUDE.md</h3>

<p>CLAUDE.md. Это файл инструкций, который Claude Code читает автоматически при каждом запуске в проекте. Он задаёт контекст: какой стек используется, какие соглашения по коду, какая структура проекта.</p>

<pre><code>Создай файл CLAUDE.md для этого проекта на основе ТЗ выше.
Включи: описание проекта, стек, структуру папок, соглашения
по именованию, ключевые зависимости. Формат: краткий, для
автоматического чтения агентом.</code></pre>

<h3>Инициализация проекта</h3>

<pre><code>/init</code></pre>

<p>Или вручную попросите Claude Code создать проект:</p>

<pre><code>Создай Next.js 15 проект с TypeScript, Tailwind CSS, shadcn/ui.
Установи зависимости: @supabase/supabase-js, @supabase/ssr, openai.
Настрой структуру папок по ТЗ. Инициализируй git.</code></pre>

<p><strong>Время:</strong> 30 минут. К 08:30 у вас есть ТЗ, CLAUDE.md и пустой, но настроенный проект.</p>

<h2>Этап 2: До обеда. Каркас (08:30 - 10:30)</h2>

<h3>Базовые страницы</h3>

<pre><code>Создай лендинг (главную страницу) для ContentPlan AI.
Заголовок: "Контент-план на месяц за 2 минуты"
Подзаголовок: описание ценности для маркетологов и предпринимателей.
Секции: hero, как это работает (3 шага), pricing (free: 1 план/мес,
pro: безлимит за $9/мес), CTA.
Дизайн: минималистичный, тёмная тема, shadcn/ui компоненты.</code></pre>

<p>Claude Code сгенерирует страницу целиком. Проверьте в браузере (npm run dev), скорректируйте текст или расположение элементов.</p>

<h3>Подключение Supabase</h3>

<pre><code>Настрой подключение к Supabase:
1. Создай lib/supabase/client.ts (клиентский) и lib/supabase/server.ts
   (серверный) клиенты
2. Создай таблицы в Supabase через миграцию:
   - profiles (id, email, plan, created_at)
   - content_plans (id, user_id, niche, audience, plan_data jsonb, created_at)
3. Настрой RLS: пользователь видит только свои планы</code></pre>

<h3>Авторизация</h3>

<pre><code>Реализуй авторизацию через Supabase Auth:
- Страница /login с формой email + magic link
- Middleware для защиты роутов /dashboard/*
- Хук useUser для клиентских компонентов
- Редирект после авторизации на /dashboard</code></pre>

<p><strong>Чекпоинт.</strong> Сделайте коммит. Не пропускайте этот шаг.</p>

<pre><code>Сделай git add и commit с сообщением "feat: base layout,
supabase auth, landing page"</code></pre>

<p><strong>Время:</strong> 2 часа. К 10:30 есть лендинг, авторизация и база данных. Каркас готов.</p>

<h2>Этап 3: После обеда. Ключевая фича (12:00 - 15:00)</h2>

<p>Это главная часть дня. Здесь рождается продукт.</p>

<h3>Генерация контент-плана</h3>

<pre><code>Создай страницу /dashboard/generate:

Форма: два поля (ниша, описание целевой аудитории) + кнопка "Сгенерировать".
При отправке: вызов API-роута /api/generate, который:
1. Принимает niche и audience из формы
2. Отправляет промпт в OpenAI API (gpt-4o)
3. Получает контент-план на 30 дней в JSON-формате
4. Сохраняет результат в таблицу content_plans
5. Редиректит на /dashboard/plans/[id]

Промпт для OpenAI должен генерировать для каждого дня:
- Тема поста
- Формат (текст / карусель / видео / опрос)
- Этап воронки (ToFu / MoFu / BoFu)
- Хук (первое предложение)
- Краткое описание содержания

Показывай loading-состояние во время генерации.
Обработай ошибки: лимит API, сетевые проблемы, невалидный ответ.</code></pre>

<h3>Итерации</h3>

<p>Первая версия будет работать, но сыроватой. Вот промпты для доработки:</p>

<pre><code>Добавь валидацию формы: ниша обязательна (минимум 3 символа),
аудитория обязательна (минимум 10 символов). Покажи ошибки
под полями, не алертом.</code></pre>

<pre><code>Страница просмотра плана /dashboard/plans/[id]:
Таблица с 30 строками. Колонки: день, тема, формат, воронка, хук.
Добавь фильтрацию по этапу воронки и по формату.
Кнопка "Экспорт в CSV".</code></pre>

<pre><code>Сделай мобильную версию. Таблицу на мобильных замени
на карточки. Форма генерации должна занимать всю ширину экрана.
Проверь, что ничего не ломается на ширине 375px.</code></pre>

<h3>Работа с багами</h3>

<p>Баги будут. Это нормально. Для быстрого исправления важно точно описать проблему.</p>

<p><strong>Плохо:</strong> "Не работает генерация"</p>
<p><strong>Хорошо:</strong></p>

<pre><code>При нажатии на кнопку "Сгенерировать" получаю ошибку в консоли:
"TypeError: Cannot read properties of undefined (reading 'choices')".
Запрос к /api/generate возвращает 200, но тело ответа пустое.
Проверь, правильно ли парсится ответ от OpenAI.</code></pre>

<p>Чем точнее описание (что произошло, что ожидалось, что в консоли), тем быстрее Claude Code найдёт решение.</p>

<p><strong>Коммит:</strong></p>

<pre><code>git add -A && git commit -m "feat: content plan generation,
plan view, mobile responsive"</code></pre>

<p><strong>Время:</strong> 3 часа. К 15:00 есть работающий продукт с основной фичей.</p>

<h2>Этап 4: Вечер. Полировка и деплой (15:30 - 17:00)</h2>

<h3>SEO-минимум</h3>

<pre><code>Добавь SEO-основы:
1. Метатеги для всех страниц (title, description, og:image, og:title)
2. Файл sitemap.xml (динамический, через Next.js route handler)
3. Файл robots.txt
4. Компонент OG-картинки через next/og для динамических страниц
5. Favicon и manifest.json</code></pre>

<h3>Деплой на Vercel</h3>

<p>Если у вас ещё нет аккаунта на Vercel, создайте. Деплой через git:</p>

<pre><code>1. Создай репозиторий на GitHub
2. Запуши код: git remote add origin [url] && git push -u origin main
3. В Vercel: Import Project, выбери репозиторий
4. Добавь env-переменные: NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY,
   SUPABASE_SERVICE_ROLE_KEY, OPENAI_API_KEY
5. Deploy</code></pre>

<p>Vercel подхватит Next.js автоматически. Каждый следующий git push запускает новый деплой.</p>

<h3>Подключение домена</h3>

<p>В настройках проекта на Vercel: Settings, Domains, Add. Введите домен, настройте DNS-записи у регистратора. Vercel выдаст SSL-сертификат автоматически.</p>

<h3>Финальная проверка</h3>

<pre><code>Проверь продакшен-версию:
1. Авторизация работает (magic link приходит на email)
2. Генерация плана отрабатывает без ошибок
3. Данные сохраняются в Supabase
4. Мобильная версия выглядит корректно
5. Метатеги отдаются правильно (проверь через curl -I)
6. Нет console.log и дебаг-кода в продакшене</code></pre>

<p><strong>Время:</strong> 1.5 часа. К 17:00 продукт доступен по реальному URL.</p>

<h2>Чеклист запуска</h2>

<p>Перед тем как показать продукт людям, пройдитесь по списку:</p>

<ul>
<li><strong>Работоспособность:</strong> основной сценарий (регистрация, генерация, просмотр) проходит без ошибок</li>
<li><strong>Мобильная версия:</strong> проверена на реальном телефоне, не только в DevTools</li>
<li><strong>Обработка ошибок:</strong> при падении API пользователь видит понятное сообщение, а не белый экран</li>
<li><strong>Скорость:</strong> лендинг загружается за 2-3 секунды на мобильном интернете</li>
<li><strong>Тексты:</strong> нет Lorem ipsum, нет "test" в заголовках, нет дефолтных описаний</li>
<li><strong>Favicon:</strong> не стандартный Next.js треугольник</li>
<li><strong>Env-переменные:</strong> все прокинуты в Vercel, ничего не захардкожено в коде</li>
<li><strong>Приватность:</strong> RLS в Supabase настроен, пользователь не видит чужие данные</li>
</ul>

<h2>Типичные ошибки первого запуска</h2>

<ol>
<li><strong>Перфекционизм.</strong> "Ещё одну фичу, и тогда покажу." Нет. MVP работает. Покажите его людям сегодня.</li>
<li><strong>Игнорирование мобильной версии.</strong> Больше половины трафика придёт с телефонов. Если на мобильном сломано, считайте, что продукта нет.</li>
<li><strong>Забытые env-переменные.</strong> Локально всё работает, на Vercel белый экран. Проверяйте переменные окружения дважды.</li>
<li><strong>Нет обработки ошибок.</strong> OpenAI API может вернуть 429 (лимит) или 500. Без обработки пользователь увидит крашнутую страницу.</li>
<li><strong>Попытка сделать всё самому.</strong> Claude Code пишет код. Вы принимаете продуктовые решения. Не наоборот.</li>
</ol>

<h2>Следующий день: что делать после запуска</h2>

<ol>
<li><strong>Аналитика.</strong> Подключите Vercel Analytics или Plausible. Смотрите: сколько людей доходит до генерации, сколько возвращается на следующий день.</li>
<li><strong>Фидбэк.</strong> Попросите 5-10 человек попробовать продукт. Наблюдайте, где они застревают. Это важнее любых метрик.</li>
<li><strong>Итерации.</strong> На основе фидбэка выберите одну вещь для улучшения. Одну, не пять. Попросите Claude Code реализовать. Задеплойте. Повторите.</li>
</ol>

<p>Один день, один MVP, один деплой. Продукт не идеальный, зато работающий. Его можно показать реальным людям и получить реальный фидбэк. А это полезнее недель планирования.</p>`
  }
]

async function seed() {
  for (const item of items) {
    const { data, error } = await supabase
      .from('comm_content_items')
      .upsert(item, { onConflict: 'slug' })
      .select('id, slug')
      .single()
    if (error) {
      console.error('Error inserting', item.slug, ':', error.message)
    } else {
      console.log('OK:', data.slug, '→', data.id)
    }
  }
}

seed().catch(console.error)
